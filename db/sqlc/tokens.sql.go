// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: tokens.sql

package db

import (
	"context"
	"database/sql"
)

const deleteAllTokenByKeyId = `-- name: DeleteAllTokenByKeyId :exec
DELETE FROM tokens WHERE apps_id = ? AND key_id = ?
`

type DeleteAllTokenByKeyIdParams struct {
	AppsID string `json:"apps_id"`
	KeyID  string `json:"key_id"`
}

func (q *Queries) DeleteAllTokenByKeyId(ctx context.Context, arg DeleteAllTokenByKeyIdParams) error {
	_, err := q.db.ExecContext(ctx, deleteAllTokenByKeyId, arg.AppsID, arg.KeyID)
	return err
}

const deleteAllTokensByAppId = `-- name: DeleteAllTokensByAppId :exec
DELETE FROM tokens WHERE apps_id = ?
`

func (q *Queries) DeleteAllTokensByAppId(ctx context.Context, appsID string) error {
	_, err := q.db.ExecContext(ctx, deleteAllTokensByAppId, appsID)
	return err
}

const deleteExpiredTokens = `-- name: DeleteExpiredTokens :exec
DELETE FROM tokens WHERE refresh_token_exp < ?
`

func (q *Queries) DeleteExpiredTokens(ctx context.Context, refreshTokenExp int64) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredTokens, refreshTokenExp)
	return err
}

const deleteTokenByAuthTokenHash = `-- name: DeleteTokenByAuthTokenHash :exec
DELETE FROM tokens WHERE apps_id = ? AND auth_token_hash = ?
`

type DeleteTokenByAuthTokenHashParams struct {
	AppsID        string `json:"apps_id"`
	AuthTokenHash string `json:"auth_token_hash"`
}

func (q *Queries) DeleteTokenByAuthTokenHash(ctx context.Context, arg DeleteTokenByAuthTokenHashParams) error {
	_, err := q.db.ExecContext(ctx, deleteTokenByAuthTokenHash, arg.AppsID, arg.AuthTokenHash)
	return err
}

const deleteTokenByTokenId = `-- name: DeleteTokenByTokenId :exec
DELETE FROM tokens WHERE token_id = ? AND apps_id = ? LIMIT 1
`

type DeleteTokenByTokenIdParams struct {
	TokenID string `json:"token_id"`
	AppsID  string `json:"apps_id"`
}

func (q *Queries) DeleteTokenByTokenId(ctx context.Context, arg DeleteTokenByTokenIdParams) error {
	_, err := q.db.ExecContext(ctx, deleteTokenByTokenId, arg.TokenID, arg.AppsID)
	return err
}

const getActiveSessionAgainstSubject = `-- name: GetActiveSessionAgainstSubject :many
SELECT token_id, key_id, 
auth_token_iat, auth_token_nbf, auth_token_exp, 
refresh_token_iat, refresh_token_nbf, refresh_token_exp,
ip_address, user_agent
FROM tokens
WHERE apps_id = ? AND sub = ? AND auth_token_exp > ? AND auth_token_nbf < ?
`

type GetActiveSessionAgainstSubjectParams struct {
	AppsID       string `json:"apps_id"`
	Sub          string `json:"sub"`
	AuthTokenExp int64  `json:"auth_token_exp"`
	AuthTokenNbf int64  `json:"auth_token_nbf"`
}

type GetActiveSessionAgainstSubjectRow struct {
	TokenID         string `json:"token_id"`
	KeyID           string `json:"key_id"`
	AuthTokenIat    int64  `json:"auth_token_iat"`
	AuthTokenNbf    int64  `json:"auth_token_nbf"`
	AuthTokenExp    int64  `json:"auth_token_exp"`
	RefreshTokenIat int64  `json:"refresh_token_iat"`
	RefreshTokenNbf int64  `json:"refresh_token_nbf"`
	RefreshTokenExp int64  `json:"refresh_token_exp"`
	IpAddress       string `json:"ip_address"`
	UserAgent       string `json:"user_agent"`
}

func (q *Queries) GetActiveSessionAgainstSubject(ctx context.Context, arg GetActiveSessionAgainstSubjectParams) ([]GetActiveSessionAgainstSubjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveSessionAgainstSubject,
		arg.AppsID,
		arg.Sub,
		arg.AuthTokenExp,
		arg.AuthTokenNbf,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveSessionAgainstSubjectRow
	for rows.Next() {
		var i GetActiveSessionAgainstSubjectRow
		if err := rows.Scan(
			&i.TokenID,
			&i.KeyID,
			&i.AuthTokenIat,
			&i.AuthTokenNbf,
			&i.AuthTokenExp,
			&i.RefreshTokenIat,
			&i.RefreshTokenNbf,
			&i.RefreshTokenExp,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenByAuthHash = `-- name: GetTokenByAuthHash :one
SELECT a.token_id, a.apps_id, a.key_id, b.key_type, b.key_algo, b.public_key
FROM tokens as a
LEFT JOIN app_keys as b ON a.apps_id = b.app_id AND a.key_id = b.key_id
WHERE a.apps_id = ? AND a.auth_token_hash = ? AND a.auth_token_exp > ? AND a.auth_token_nbf < ?
LIMIT 1
`

type GetTokenByAuthHashParams struct {
	AppsID        string `json:"apps_id"`
	AuthTokenHash string `json:"auth_token_hash"`
	AuthTokenExp  int64  `json:"auth_token_exp"`
	AuthTokenNbf  int64  `json:"auth_token_nbf"`
}

type GetTokenByAuthHashRow struct {
	TokenID   string             `json:"token_id"`
	AppsID    string             `json:"apps_id"`
	KeyID     string             `json:"key_id"`
	KeyType   NullAppKeysKeyType `json:"key_type"`
	KeyAlgo   NullAppKeysKeyAlgo `json:"key_algo"`
	PublicKey sql.NullString     `json:"public_key"`
}

func (q *Queries) GetTokenByAuthHash(ctx context.Context, arg GetTokenByAuthHashParams) (GetTokenByAuthHashRow, error) {
	row := q.db.QueryRowContext(ctx, getTokenByAuthHash,
		arg.AppsID,
		arg.AuthTokenHash,
		arg.AuthTokenExp,
		arg.AuthTokenNbf,
	)
	var i GetTokenByAuthHashRow
	err := row.Scan(
		&i.TokenID,
		&i.AppsID,
		&i.KeyID,
		&i.KeyType,
		&i.KeyAlgo,
		&i.PublicKey,
	)
	return i, err
}

const getTokenByRefreshHash = `-- name: GetTokenByRefreshHash :one
SELECT a.token_id, a.apps_id, a.key_id, a.sub, a.auth_token, b.key_type, b.key_algo, b.public_key
FROM tokens as a
LEFT JOIN app_keys as b ON a.apps_id = b.app_id AND a.key_id = b.key_id
WHERE a.apps_id = ? AND a.refresh_token_hash = ? AND a.refresh_token_exp > ? AND a.refresh_token_nbf < ?
LIMIT 1
`

type GetTokenByRefreshHashParams struct {
	AppsID           string `json:"apps_id"`
	RefreshTokenHash string `json:"refresh_token_hash"`
	RefreshTokenExp  int64  `json:"refresh_token_exp"`
	RefreshTokenNbf  int64  `json:"refresh_token_nbf"`
}

type GetTokenByRefreshHashRow struct {
	TokenID   string             `json:"token_id"`
	AppsID    string             `json:"apps_id"`
	KeyID     string             `json:"key_id"`
	Sub       string             `json:"sub"`
	AuthToken string             `json:"auth_token"`
	KeyType   NullAppKeysKeyType `json:"key_type"`
	KeyAlgo   NullAppKeysKeyAlgo `json:"key_algo"`
	PublicKey sql.NullString     `json:"public_key"`
}

func (q *Queries) GetTokenByRefreshHash(ctx context.Context, arg GetTokenByRefreshHashParams) (GetTokenByRefreshHashRow, error) {
	row := q.db.QueryRowContext(ctx, getTokenByRefreshHash,
		arg.AppsID,
		arg.RefreshTokenHash,
		arg.RefreshTokenExp,
		arg.RefreshTokenNbf,
	)
	var i GetTokenByRefreshHashRow
	err := row.Scan(
		&i.TokenID,
		&i.AppsID,
		&i.KeyID,
		&i.Sub,
		&i.AuthToken,
		&i.KeyType,
		&i.KeyAlgo,
		&i.PublicKey,
	)
	return i, err
}

const insertToken = `-- name: InsertToken :exec
INSERT INTO tokens (token_id, apps_id, key_id, sub,
auth_token, auth_token_hash, auth_token_iat, auth_token_nbf, auth_token_exp, 
refresh_token, refresh_token_hash, refresh_token_iat, refresh_token_nbf, refresh_token_exp, 
ip_address, user_agent) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
`

type InsertTokenParams struct {
	TokenID          string `json:"token_id"`
	AppsID           string `json:"apps_id"`
	KeyID            string `json:"key_id"`
	Sub              string `json:"sub"`
	AuthToken        string `json:"auth_token"`
	AuthTokenHash    string `json:"auth_token_hash"`
	AuthTokenIat     int64  `json:"auth_token_iat"`
	AuthTokenNbf     int64  `json:"auth_token_nbf"`
	AuthTokenExp     int64  `json:"auth_token_exp"`
	RefreshToken     string `json:"refresh_token"`
	RefreshTokenHash string `json:"refresh_token_hash"`
	RefreshTokenIat  int64  `json:"refresh_token_iat"`
	RefreshTokenNbf  int64  `json:"refresh_token_nbf"`
	RefreshTokenExp  int64  `json:"refresh_token_exp"`
	IpAddress        string `json:"ip_address"`
	UserAgent        string `json:"user_agent"`
}

func (q *Queries) InsertToken(ctx context.Context, arg InsertTokenParams) error {
	_, err := q.db.ExecContext(ctx, insertToken,
		arg.TokenID,
		arg.AppsID,
		arg.KeyID,
		arg.Sub,
		arg.AuthToken,
		arg.AuthTokenHash,
		arg.AuthTokenIat,
		arg.AuthTokenNbf,
		arg.AuthTokenExp,
		arg.RefreshToken,
		arg.RefreshTokenHash,
		arg.RefreshTokenIat,
		arg.RefreshTokenNbf,
		arg.RefreshTokenExp,
		arg.IpAddress,
		arg.UserAgent,
	)
	return err
}
